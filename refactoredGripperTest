"""
using robot_test_motor.py as baseline (by David Valencia)
but refactored to make it less than 500 lines and easier to 
add and control more motors. 
Beth Cutler 
"""

#region ***IMPORTS, SETUP***

import os, time
import numpy as np
from dynamixel_sdk import *          # Uses Dynamixel SDK library


if os.name == 'nt':
    import msvcrt
    def getch():
        return msvcrt.getch().decode()
    
else:
    import sys, tty, termios

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)

    def getch():
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

#endregion 

#region ***GLOBALS***

#addresses for motor settings
ADDR_TORQUE_ENABLE = 24
ADDR_GOAL_POSITION = 30
ADDR_MOVING_SPEED = 32
ADDR_TORQUE_LIMIT = 35
ADDR_PRESENT_POSITION = 37

#protcal and baud rate
PROTOCOL_VERSION = 2.0
BAUDRATE = 57600

#NTS not gonna use ids for now, but will have input for number of motors
NUM_MOTORS = 9

#u2d2 assigned port
DEVICENAME = 'COM5'

TORQUE_ENABLE  = 1  # Value for enabling the torque
TORQUE_DISABLE = 0  # Value for disabling the torque        

# setting max velocity and torque
MAX_VELOCITY_VALUE = 100   # Max possible value=2047
LIM_TORQUE_VALUE   = 180    # Max possible value=1023

#doing this without indvidual ids is gonna be interesting but umm ok
#goal values (make 2d array 2*NUM_MOTORS, set to 0)

goal_values = np.array([[400, 500, 600, 500], #1
               [400, 500, 600, 500], #2
               [400, 500, 600, 500], #3
               [400, 500, 600, 500], #4
               [400, 500, 600, 500], #5
               [400, 500, 600, 500], #6
               [400, 500, 600, 500], #7
               [400, 500, 600, 500], #8
               [400, 500, 600, 500]]) #9

portHandler = PortHandler(DEVICENAME)
packetHandler = PacketHandler(PROTOCOL_VERSION)

#endregion 

#region ***PORT STUFF***

#open port
if portHandler.openPort():
    print("Succeeded to open the port")
else:
    print("Failed to open the port")
    print("Press any key to terminate...")
    getch()
    quit()

#set port baudrate
if portHandler.setBaudRate(BAUDRATE):
    print("Succeeded to change the baudrate")
else:
    print("Failed to change the baudrate")
    print("Press any key to terminate...")
    getch()
    quit()

#endregion

#region ***TORQUE LIMITS***

for i in range(1, NUM_MOTORS+1):
    dxl_comm_result, dxl_error = packetHandler.write2ByteTxRx(portHandler, i, ADDR_TORQUE_LIMIT, LIM_TORQUE_VALUE)
    if dxl_comm_result != COMM_SUCCESS:
        print("%s" % packetHandler.getTxRxResult(dxl_comm_result))
    elif dxl_error != 0:
        print("%s" % packetHandler.getRxPacketError(dxl_error))
    else:
        print("Dynamixel#%d has been successfully torque limited" % i)

#endregion

#region ***TORQUE ENABLE***
for i in range(1, NUM_MOTORS+1):
    dxl_comm_result, dxl_error = packetHandler.write1ByteTxRx(portHandler, i, ADDR_TORQUE_ENABLE, TORQUE_ENABLE)
    if dxl_comm_result != COMM_SUCCESS:
        print("%s" % packetHandler.getTxRxResult(dxl_comm_result))
    elif dxl_error != 0:
        print("%s" % packetHandler.getRxPacketError(dxl_error))
    else:
        print("Dynamixel#%d has been successfully torque enabled" % i)
#endregion

#region ***LIMT MOVING SPEED***
for i in range(1, NUM_MOTORS+1):
    dxl_comm_result, dxl_error = packetHandler.write2ByteTxRx(portHandler, i, ADDR_MOVING_SPEED, MAX_VELOCITY_VALUE)
    if dxl_comm_result != COMM_SUCCESS:
        print("%s" % packetHandler.getTxRxResult(dxl_comm_result))
    elif dxl_error != 0:
        print("%s" % packetHandler.getRxPacketError(dxl_error))
    else:
        print("Dynamixel#%d has been successfully speed limited" % i)

#endregion

#region ***WRITE GOAL POSITION*** --> use keyboard interupt to stop infintite loop

# Initialize GroupSyncWrite instance ---> GroupSyncWrite(port, ph, start_address, data_length)
data_length = 2 #number of bytes to write
groupSyncWrite = GroupSyncWrite(portHandler, packetHandler, ADDR_GOAL_POSITION, data_length)

while 1:
    #initialise paramGoalPositions
    paramGoalPositions = np.zeros((NUM_MOTORS, data_length), dtype=np.uint8)

    for j in range(0,(np.shape(goal_values)[1])): 
        
        #add goal positions to paramGoalPositions 
        for i in range(0, NUM_MOTORS): 
                    dxl_addparam_result = groupSyncWrite.addParam(i, [DXL_LOBYTE(goal_values[i, j]), DXL_HIBYTE(goal_values[i, j])])
                    #check for success
                    if dxl_addparam_result != True:
                        print("[ID:%03d] groupSyncWrite addparam failed" % i)
                        quit() 

        #transmit goal position to motors
        dxl_comm_result = groupSyncWrite.txPacket()
        if dxl_comm_result == COMM_SUCCESS:
            print("%s" % packetHandler.getTxRxResult(dxl_comm_result))
            
        #delay (in seconds)
        time.sleep(1)
        groupSyncWrite.clearParam()

#endregion

#clear port
portHandler.closePort()
print("port closed")
    
