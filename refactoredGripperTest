"""
using robot_test_motor.py as baseline (by David Valencia)
but refactored to make it less than 500 lines and easier to 
add and control more motors. 
Beth Cutler 
"""

#region ***IMPORTS, SETUP***

import os
import numpy as np
from dynamixel_sdk import *    
#from dynamixel_sdk.port_handler import PortHandler
#from dynamixel_sdk.packet_handler import PacketHandler
#from dynamixel_sdk.robotis_def import *                # Uses Dynamixel SDK library


if os.name == 'nt':
    import msvcrt
    def getch():
        return msvcrt.getch().decode()
    
else:
    import sys, tty, termios

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)

    def getch():
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

#endregion 

#region ***GLOBALS***

#addresses for motor settings
ADDR_TORQUE_ENABLE = 24
ADDR_GOAL_POSITION = 30
ADDR_MOVING_SPEED = 32
ADDR_TORQUE_LIMIT = 35
ADDR_PRESENT_POSITION = 37

#protcal and baud rate
PROTOCOL_VERSION = 2.0
BAUDRATE = 57600

#NTS not gonna use ids for now, but will have input for number of motors
NUM_MOTORS = 9

#u2d2 assigned port
DEVICENAME = 'COM5'

TORQUE_ENABLE  = 1  # Value for enabling the torque
TORQUE_DISABLE = 0  # Value for disabling the torque

# setting max velocity and torque
MAX_VELOCITY_VALUE = 100   # Max possible value=2047
LIM_TORQUE_VALUE   = 180    # Max possible value=1023

#doing this without indvidual ids is gonna be interesting but umm ok
#goal values (make 2d array 2*NUM_MOTORS, set to 0)

goal_values = [[450, 550, 500], #1
               [450, 550, 500], #2
               [450, 550, 500], #3
               [450, 550, 500], #4
               [450, 550, 500], #5
               [450, 550, 500], #6
               [450, 550, 500], #7
               [450, 550, 500], #8
               [450, 550, 500]] #9

portHandler = PortHandler(DEVICENAME)
packetHandler = PacketHandler(PROTOCOL_VERSION)

#endregion 

#region ***PORT STUFF***

#open port
if portHandler.openPort():
    print("Succeeded to open the port")
else:
    print("Failed to open the port")
    print("Press any key to terminate...")
    getch()
    quit()

#set port baudrate
if portHandler.setBaudRate(BAUDRATE):
    print("Succeeded to change the baudrate")
else:
    print("Failed to change the baudrate")
    print("Press any key to terminate...")
    getch()
    quit()

#endregion

#region ***TORQUE LIMITS***

for i in range(1, NUM_MOTORS):
    dxl_comm_result, dxl_error = packetHandler.write2ByteTxRx(portHandler, i, ADDR_TORQUE_LIMIT, LIM_TORQUE_VALUE)
    if dxl_comm_result != COMM_SUCCESS:
        print("%s" % packetHandler.getTxRxResult(dxl_comm_result))
    elif dxl_error != 0:
        print("%s" % packetHandler.getRxPacketError(dxl_error))
    else:
        print("Dynamixel#%d has been successfully connected" % i)

#endregion

#region ***TORQUE ENABLE***
for i in range(1, NUM_MOTORS):
    dxl_comm_result, dxl_error = packetHandler.write1ByteTxRx(portHandler, i, ADDR_TORQUE_ENABLE, TORQUE_ENABLE)
    if dxl_comm_result != COMM_SUCCESS:
        print("%s" % packetHandler.getTxRxResult(dxl_comm_result))
    elif dxl_error != 0:
        print("%s" % packetHandler.getRxPacketError(dxl_error))
    else:
        print("Dynamixel#%d has been successfully connected" % i)
#endregion

#region ***LIMT MOVING SPEED***
for i in range(1, NUM_MOTORS):
    dxl_comm_result, dxl_error = packetHandler.write2ByteTxRx(portHandler, i, ADDR_MOVING_SPEED, MAX_VELOCITY_VALUE)
    if dxl_comm_result != COMM_SUCCESS:
        print("%s" % packetHandler.getTxRxResult(dxl_comm_result))
    elif dxl_error != 0:
        print("%s" % packetHandler.getRxPacketError(dxl_error))
    else:
        print("Dynamixel#%d has been successfully connected" % i)

#endregion

#region ***WRITE GOAL POSITION***
# Initialize GroupSyncWrite instance ---> GroupSyncWrite(port, ph, start_address, data_length)

data_length = 3 #amount of steps to test

groupSyncWrite = GroupSyncWrite(portHandler, packetHandler, ADDR_GOAL_POSITION, data_length)

while 1: #start testing --> need to remember that this big loop keeps going for ages
    print("press any key to continue! (or press ESC to quit!)")
    if getch() == chr(0x1b):
        break
    
    paramGoalPositions = np.zeros((NUM_MOTORS, data_length), dtype=np.uint8)

    #add goal positions to paramGoalPositions using special format
    for i in range(0, NUM_MOTORS-1):
                paramGoalPositions[i][0] = DXL_LOBYTE(goal_values[i][j])
                paramGoalPositions[i][1] = DXL_HIBYTE(goal_values[i][j])  #need to figure out how to deal with long data sizes 
        
#also i remember things being dumb with indexing python arrays so we'll have to figure that out
#might just replace it with numpy
